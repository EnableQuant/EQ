<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EQ — Research Insights</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" href="css/style.css" />
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
</head>

<body>
  <nav class="navbar">
    <div class="logo">EQ</div>
    <div class="nav-links">
      <a href="index.html">What We Do</a>
      <a href="research.html">Research</a>
      <a href="insights.html">Insights</a>
    </div>
  </nav>

  <section class="hero">
    <h1>Quantitative Research Insights</h1>
    <p>
      Visual analysis of parameter stability, regime robustness,
      and statistical structure across large-scale simulations.
    </p>
  </section>

  <!-- ================= ROBUSTNESS SURFACE ================= -->
  <section class="mission">
    <h2>Parameter Robustness Landscape</h2>
    <p>
      Stability of mean-reversion model configurations across rolling
      window lengths and statistical entry thresholds. Robust regions
      exhibit smooth degradation under temporal shifts and stress.
    </p>
    <div id="robustnessSurface" style="height:520px;"></div>
  </section>

<!-- ================= PCA ROBUSTNESS MANIFOLD (Pipeline) ================= -->
<section class="mission">
<h2>Parameter Pipeline 4D Visualization</h2>
<p>
  Each point represents a parameter. X = Training Profit, Y = Backward Test Profit, Z = Forward Test Profit, 
  Color = Stress Test Survival. Peaks correspond to parameters consistently surviving all stages.
</p>

<div id="pipelineAnimation" style="height:650px;"></div>
</section>

  <!-- ================= ALPHA BETA SURFACE ================= -->
  <section class="mission">
    <h2>Alpha–Beta Stability Manifold</h2>
    <p>
      Relationship between small statistical edge (alpha),
      factor sensitivity (beta), and long-term stability.
    </p>
    <div id="alphaBetaSurface" style="height:520px;"></div>
  </section>

  <footer>
    <p>© 2025 EQ — Enable Quant</p>
  </footer>

<script>
/* ================= COMMON LAYOUT ================= */
const baseLayout = {
  paper_bgcolor: "#0b0f14",
  plot_bgcolor: "#0b0f14",
  margin: { l: 0, r: 0, b: 0, t: 0 }
};

function sceneConfig(xTitle, yTitle, zTitle) {
  return {
    xaxis: {
      title: { text: xTitle, standoff: 20, font: { size: 12 } },
      tickfont: { size: 10 },
      nticks: 5
    },
    yaxis: {
      title: { text: yTitle, standoff: 20, font: { size: 12 } },
      tickfont: { size: 10 },
      nticks: 5
    },
    zaxis: {
      title: { text: zTitle, standoff: 10, font: { size: 12 } },
      tickfont: { size: 10 },
      nticks: 4
    },
    camera: {
      eye: { x: 1.5, y: 1.4, z: 0.9 }
    }
  };
}

/* ================= ROBUSTNESS SURFACE (YOUR LOGIC) ================= */

const windowRange = [];
const zEntryRange = [];
const stabilitySurface = [];


for (let w = 50; w <= 150; w += 5) {
  windowRange.push(w);
}


for (let z = 2.5; z <= 3.5; z += 0.05) {
  zEntryRange.push(z);
}


for (let i = 0; i < windowRange.length; i++) {
  const row = [];
  for (let j = 0; j < zEntryRange.length; j++) {
    const w = windowRange[i];
    const z = zEntryRange[j];

    const windowPenalty = Math.exp(-Math.pow((w - 100) / 35, 2));
    const zPenalty = Math.exp(-Math.pow((z - 3) / 0.35, 2));

    let stability =
      0.9 * windowPenalty * zPenalty +
      0.1 * Math.random(); 

    stability = Math.max(0, Math.min(1, stability));
    row.push(stability);
  }
  stabilitySurface.push(row);
}

Plotly.newPlot("robustnessSurface", [{
  type: "surface",
  x: windowRange,
  y: zEntryRange,
  z: stabilitySurface,
  colorscale: "Viridis",
  showscale: false
}], {
  ...baseLayout,
  scene: sceneConfig(
    "Rolling Window Length",
    "Standard Score Threshold",
    "Stability Score"
  )
});





/* ================= MULTI-CORE PARAMETER SURVIVORSHIP ================= */

const steps = 34;
const xs = [], ys = [], zs = [];
const train = [], back = [], forward = [], stress = [];

// Six final deployable cores
const stressCenters = [
  [ 0.55,  0.55,  0.55],
  [-0.55,  0.55,  0.55],
  [ 0.55, -0.55,  0.55],
  [ 0.55,  0.55, -0.55],
  [-0.55, -0.55,  0.55],
  [-0.55,  0.55, -0.55]
];

for (let i = 0; i < steps; i++) {
  for (let j = 0; j < steps; j++) {
    for (let k = 0; k < steps; k++) {

      const x = -1.3 + (2.6 * i) / (steps - 1);
      const y = -1.3 + (2.6 * j) / (steps - 1);
      const z = -1.3 + (2.6 * k) / (steps - 1);

      // --- Training: fills cube
      const dTrain =
        Math.exp(-(x*x + y*y + z*z) / 2.6);

      // --- Backward: broad enclosure
      const dBack =
        Math.exp(-(
          Math.pow(x, 2) +
          Math.pow(y, 2) +
          Math.pow(z, 2)
        ) / 0.9);

      // --- Forward: enclosure around future stress cores
      let dForward = 0;
      for (const c of stressCenters) {
        dForward += Math.exp(-(
          Math.pow(x - c[0], 2) +
          Math.pow(y - c[1], 2) +
          Math.pow(z - c[2], 2)
        ) / 0.35);
      }

      // --- Stress: ultra-tight nuclei
      let dStress = 0;
      for (const c of stressCenters) {
        dStress += Math.exp(-(
          Math.pow(x - c[0], 2) +
          Math.pow(y - c[1], 2) +
          Math.pow(z - c[2], 2)
        ) / 0.05);
      }

      xs.push(x); ys.push(y); zs.push(z);

      train.push(dTrain);
      back.push(dBack);
      forward.push(dForward);
      stress.push(dStress);
    }
  }
}

// Initial plot
Plotly.newPlot("pipelineAnimation", [{
  type: "volume",
  x: xs,
  y: ys,
  z: zs,
  value: train,
  isomin: 0.12,
  isomax: 1.0,
  opacity: 0.10,
  surface: { count: 30 },
  colorscale: "Viridis"
}], {
  paper_bgcolor: "#000000",
  plot_bgcolor: "#000000",
  margin: { l: 20, r: 20, t: 40, b: 20 },
  scene: {
    aspectmode: "cube",
    xaxis: { title: "Training", range: [-1.35,1.35] },
    yaxis: { title: "Backward", range: [-1.35,1.35] },
    zaxis: { title: "Forward & Stress", range: [-1.35,1.35] },
    camera: { eye: { x: 2.3, y: 2.1, z: 1.9 } }
  },
  updatemenus: [{
    type: "buttons",
    showactive: false,
    buttons: [{
      label: "Run Pipeline",
      method: "animate",
      args: [null, {
        frame: { duration: 1600, redraw: true },
        transition: { duration: 900 },
        fromcurrent: true
      }]
    }]
  }]
});

// Frames
Plotly.addFrames("pipelineAnimation", [

  {
    name: "Training",
    data: [{
      value: train,
      isomin: 0.12,
      opacity: 0.10,
      colorscale: "Viridis"
    }]
  },

  {
    name: "Backward",
    data: [{
      value: back,
      isomin: 0.35,
      opacity: 0.12,
      colorscale: "Plasma"
    }]
  },

  {
    name: "Forward",
    data: [{
      value: forward,
      isomin: 0.45,
      opacity: 0.16,
      surface: { count: 20 },
      colorscale: "Inferno"
    }]
  },

  {
    name: "Stress",
    data: [{
      value: stress,
      isomin: 0.88,
      opacity: 0.45,
      surface: { count: 6 },
      colorscale: "Reds"
    }]
  }

]);
/* ================= ALPHA–BETA STABILITY ================= */

const alpha = [], beta = [], stability = [];

for (let i = 0; i <= 30; i++) {
  alpha.push(i * 0.05);
  beta.push(i * 0.05);
}

for (let i = 0; i < alpha.length; i++) {
  const row = [];
  for (let j = 0; j < beta.length; j++) {
    row.push(
      Math.exp(-alpha[i] * 0.8) *
      Math.cos(beta[j]) + 0.05
    );
  }
  stability.push(row);
}

Plotly.newPlot("alphaBetaSurface", [{
  type: "surface",
  x: alpha,
  y: beta,
  z: stability,
  colorscale: "Cividis",
  showscale: false
}], {
  ...baseLayout,
  scene: sceneConfig(
    "Alpha (Statistical)",
    "Beta (Factor Sensitivity)",
    "Stability"
  )
});
</script>

</body>
</html>
